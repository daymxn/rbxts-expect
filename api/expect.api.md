## API Report File for "@rbxts/expect"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Result } from '@rbxts/rust-classes';
import { t } from '@rbxts/t';

// @public
export interface ActualPlaceholder {
    fullValue: string;
    type: string;
    value: string;
}

// @public
export interface Assertion<T = unknown> {
    readonly a: this;
    readonly also: this;
    readonly an: this;
    readonly and: this;
    anyOf<R = T>(values: R[]): Assertion<R>;
    array(): Assertion<T extends unknown[] ? T : T[]>;
    array<I extends keyof CheckableTypes>(typeName: I): Assertion<I[]>;
    array<I>(checker: TypeCheckCallback<I>): Assertion<I[]>;
    array<I>(tChecker: t.check<I>): Assertion<I[]>;
    arrayOf<I extends keyof CheckableTypes>(typeName: I): Assertion<I[]>;
    arrayOf<I>(checker: TypeCheckCallback<I>): Assertion<I[]>;
    arrayOf<I>(tChecker: t.check<I>): Assertion<I[]>;
    readonly be: this;
    readonly been: this;
    boolean(): Assertion<boolean>;
    readonly but: this;
    containExactly(expectedValues: InferArrayElement<T>[]): this;
    containExactlyInOrder(expectedValues: InferArrayElement<T>[]): this;
    containsExactly(expectedValues: InferArrayElement<T>[]): this;
    containsExactlyInOrder(expectedValues: InferArrayElement<T>[]): this;
    deepEqual<R = T>(expectedValue: R): Assertion<R>;
    deepEquals<R = T>(expectedValue: R): Assertion<R>;
    readonly does: this;
    empty(): Assertion<T>;
    enum<R>(enumType: R & Record<number, string>): Assertion<EnumValue<R>>;
    enum<R>(enumType: R & Record<number, string>, value: R[keyof R]): Assertion<EnumValue<R>>;
    enum<R>(enumType: R & Record<number, string>, value: keyof R): Assertion<EnumValue<R>>;
    enum_type?: Record<number, string>;
    eq<R = T>(expectedValue: R): Assertion<R>;
    eql<R = T>(expectedValue: R): Assertion<R>;
    equal<R = T>(expectedValue: R): Assertion<R>;
    equals<R = T>(expectedValue: R): Assertion<R>;
    function(): Assertion<object>;
    readonly have: this;
    include(expectedValue: InferArrayElement<T>): this;
    includes(expectedValue: InferArrayElement<T>): this;
    instanceOf<I extends keyof CheckableTypes>(name: I): Assertion<I>;
    instanceOf<I>(checker: TypeCheckCallback<T>): Assertion<I>;
    instanceOf<I>(tChecker: t.check<I>): Assertion<I>;
    readonly is: this;
    is_array?: boolean;
    length(size: number): this;
    lengthOf(size: number): this;
    // @internal (undocumented)
    _negated: boolean;
    readonly never: this;
    readonly not: this;
    number(): Assertion<number>;
    object(): Assertion<object>;
    readonly of: this;
    oneOf<R = T>(values: R[]): Assertion<R>;
    readonly or: this;
    // @internal (undocumented)
    _proxy?: Proxy<T>;
    // @internal (undocumented)
    _self: this;
    size(size: number): this;
    sizeOf(size: number): this;
    some(condition: Filter<InferArrayElement<T>>): this;
    some(reason: string, condition: Filter<InferArrayElement<T>>): this;
    readonly still: this;
    string(): Assertion<string>;
    substring(str: string): Assertion<T>;
    table(): Assertion<object>;
    readonly that: this;
    readonly the: this;
    throw(): Assertion<T>;
    throw(substring: string): Assertion<T>;
    throwMatch(pattern: string): Assertion<T>;
    throws(): Assertion<T>;
    throws(substring: string): Assertion<T>;
    throwsMatch(pattern: string): Assertion<T>;
    readonly to: this;
    typeOf<I extends keyof CheckableTypes>(name: I): Assertion<I>;
    typeOf<I>(checker: TypeCheckCallback<T>): Assertion<I>;
    typeOf<I>(tChecker: t.check<I>): Assertion<I>;
    readonly value: T;
    readonly which: this;
}

// @public
export function computeFullProxyPath<T>(proxy: Proxy<T>): string | undefined;

// @public
export function createProxy<T>(value: T, parent?: Proxy<unknown>, path?: string): Proxy<T>;

// @public
export type CustomMethodImpl<T = unknown> = (source: Assertion<T>, actual: T, ...args: never[]) => ExpectMethodResult;

// @public
export type CustomMethodImpls<T> = {
    [key: string]: CustomMethodImpl<T>;
};

// @public
export type EnumValue<E> = E[keyof E];

// @public
export function err(callback: () => unknown, ...messages: string[]): void;

// @public
export function expect<T>(value: T): Assertion<T>;

// @public
export interface ExpectConfig {
    collapseLength: number;
}

// @public
export interface ExpectedPlaceholder {
    fullValue: string;
    type: string;
    value: string;
}

// @public
export class ExpectMessageBuilder {
    constructor(prefix?: string, negationPrefix?: string, options?: Partial<ExpectMessageBuilderOptions>);
    actual(data: VariableData): this;
    actualType(typeStr?: string): this;
    actualValue(value?: unknown): this;
    appendPrefix(str: string): this;
    build(pass?: boolean, negated?: boolean): string;
    copy(): ExpectMessageBuilder;
    encode(value: unknown, valueType?: string, overrideOptions?: Partial<ExpectMessageBuilderOptions>, array?: boolean, collapsable?: boolean, collapseLength?: number): string;
    expected(data: VariableData): this;
    expectedType(typeStr?: string): this;
    expectedValue(value?: unknown): this;
    fail(): Result<ExpectMessageBuilder, ExpectMessageBuilder>;
    failureMetadata(data: Record<string, unknown>): this;
    failWithReason(reason: string): Result<ExpectMessageBuilder, ExpectMessageBuilder>;
    index(index?: number | string): this;
    metadata(data: Record<string, unknown>): this;
    name(value?: unknown): this;
    negationSuffix(str?: string): this;
    nestedMetadata(data: Record<string, unknown>): this;
    readonly options: ExpectMessageBuilderOptions;
    pass(): Result<ExpectMessageBuilder, ExpectMessageBuilder>;
    path(str?: string): this;
    reason(reason?: string): this;
    suffix(str?: string): this;
    surfaceMetadata(data: Record<string, unknown>): this;
    toString(): string;
    trailingFailurePrefix(str?: string): this;
    trailingFailureSuffix(str?: string): this;
    use(trailingPrefix?: string, trailingFailurePrefix?: string): ExpectMessageBuilder;
}

// @public
export interface ExpectMessageBuilderOptions {
    attachFullOnCollapse: boolean;
    trimSpaces: boolean;
    trimWhiteSpace: boolean;
    wrapValues: boolean;
}

// @public
export type ExpectMethodResult = Result<ExpectMessageBuilder, ExpectMessageBuilder>;

// @public
export function extendMethods(methods: CustomMethodImpls<never>): void;

// @public
export function extendNegations(methods: ReadonlyArray<string>): void;

// @public
export function extendNOPs(methods: ReadonlyArray<string>): void;

// @public
export type Filter<T = unknown> = (value: T) => boolean;

// @public
export function getDefaultExpectConfig(): ExpectConfig;

// @public
export function getProxyParent<T = unknown, R = unknown>(proxy: Proxy<T>): Proxy<R> | undefined;

// @public
export function getProxyPath<T = unknown>(proxy: Proxy<T>): string | undefined;

// @public
export function getProxyValue<T = unknown>(proxy: Proxy<T>): T;

// @public
export type InferArrayElement<T> = T extends (infer U)[] ? U : never;

// @public
export function isProxy<T>(value: T): value is Proxy<T>;

// @public
export type LuaEnum = Record<string | number, string>;

// @public
export const place: Placeholder;

// @public
export interface Placeholder {
    actual: ActualPlaceholder;
    expected: ExpectedPlaceholder;
    index: string;
    name: string;
    nil: string;
    not: string;
    path: string;
    reason: string;
    undefined: string;
}

// @public
export type Proxy<T> = T & ProxyInstance<T>;

// @public
export interface ProxyInstance<T> {
    _is_proxy: true;
    _proxy_parent?: Proxy<unknown>;
    _proxy_path?: string;
    _proxy_value: T;
}

// @public
export function resetDefaultExpectConfig(): void;

// @public
export function setDefaultExpectConfig(config: Partial<ExpectConfig>): void;

// @public
export type TypeCheckCallback<T = defined> = (value: T) => boolean | string | void;

// @public
export interface VariableData {
    type?: string;
    value: unknown;
}

// @public
export function withProxy<T, R = unknown>(value: T, callback: (proxy: Proxy<T>) => R): R;

```
